This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-22T23:11:40.072Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  routes/
    api.ts
  utils/
    block-fetcher.ts
  index.ts
test/
  block.fetcher.test.ts
  tsconfig.json
.gitignore
package.json
README.md
tsconfig.json
vitest.config.ts
wrangler.toml

================================================================
Repository Files
================================================================

================
File: src/routes/api.ts
================
import type { Context } from "hono";
import {
  getEVMBlockByTimestamp,
  getSolanaBlockByTimestamp,
  getTimestampByBlockNumber,
  getTimestampBySlot,
} from "../utils/block-fetcher";

const cache: Record<string, Record<string, number>> = {};

export async function handleApiRoute(c: Context) {
  const timestampsParam = c.req.query("timestamps");
  const blockNumberParam = c.req.query("blockNumber");
  const chain = c.req.query("chain") || "evm";
  const results: Record<string, number | null> = {};

  if (timestampsParam) {
    const timestamps = timestampsParam.split(",").map((ts) => ts.trim());
    for (const timestamp of timestamps) {
      if (cache[chain] && cache[chain][timestamp]) {
        results[timestamp] = cache[chain][timestamp];
      } else {
        try {
          const blockNumber = chain === "solana"
            ? await getSolanaBlockByTimestamp(Number(timestamp))
            : await getEVMBlockByTimestamp(Number(timestamp));

          if (!cache[chain]) cache[chain] = {};
          cache[chain][timestamp] = blockNumber;
          results[timestamp] = blockNumber;

          console.log(`Chain: ${chain}, Block number: ${blockNumber}, Timestamp: ${timestamp}`);
        } catch (err) {
          const errorMessage = err instanceof Error ? err.message : String(err);
          console.error(`Failed to fetch block for timestamp ${timestamp} on chain ${chain}: ${errorMessage}`);
          results[timestamp] = null;
        }
      }
    }
  } else if (blockNumberParam) {
    try {
      const blockNumber = Number(blockNumberParam);
      const timestamp = chain === "solana"
        ? await getTimestampBySlot(blockNumber)
        : await getTimestampByBlockNumber(blockNumber);

      results[blockNumberParam] = timestamp;
      console.log(`Chain: ${chain}, Block number: ${blockNumber}, Timestamp: ${timestamp}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`Error fetching timestamp for block number ${blockNumberParam} on chain ${chain}: ${errorMessage}`);
      return c.text(`Error: ${errorMessage}`, 500);
    }
  } else {
    return c.json({ error: "No timestamps or block number provided" }, 400);
  }

  return c.json(results);
}

================
File: src/utils/block-fetcher.ts
================
// src/utils/block-fetcher.ts

const EVM_RPC_URL =
  "https://mainnet.infura.io/v3/d329f1cc50934c01ae4f89c0662b71b4";
const SOLANA_RPC_URL =
  "https://solana-mainnet.g.alchemy.com/v2/bAe1SR58rtVmDbeol7FUMnPCZbvqi5WZ";

const MAX_SEARCH_OFFSET = 100;
const TIME_DIFFERENCE_THRESHOLD = 60; // seconds

const slotTimeCache: Record<number, number> = {};
const blockTimestampCache: Record<number, number> = {};

// Helper function to delay execution
export async function delay(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

// Retry function for transient errors
export async function retry<T>(
  fn: () => Promise<T>,
  retries = 3,
  delayMs = 1000
): Promise<T> {
  for (let attempt = 0; attempt < retries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt >= retries - 1)
        throw new Error(`Max retries reached: ${String(error)}`);
      await delay(delayMs);
    }
  }
  throw new Error("Max retries reached without success.");
}

// Define response types
interface EVMBlockResponse {
  result: {
    timestamp: string;
  } | null;
}

interface LatestBlockNumberResponse {
  result: string;
}

// Generic function to get cached data
async function getCachedData<T>(
  cache: Record<number, T>,
  key: number,
  fetchFunc: () => Promise<T>
): Promise<T> {
  return retry(async () => {
    if (key in cache) return cache[key];
    const data = await fetchFunc();
    cache[key] = data;
    return data;
  });
}

// EVM Functions

// Function to get block timestamp for EVM with caching
export async function getBlockTimestamp(blockNumber: number): Promise<number> {
  return getCachedData(blockTimestampCache, blockNumber, async () => {
    const response = await fetch(EVM_RPC_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        jsonrpc: "2.0",
        method: "eth_getBlockByNumber",
        params: [`0x${blockNumber.toString(16)}`, false],
        id: 1,
      }),
    });
    const data: EVMBlockResponse = await response.json();
    if (!data.result)
      throw new Error(`No data found for block number: ${blockNumber}`);
    return parseInt(data.result.timestamp, 16);
  });
}

// Function to get the latest block number (EVM)
export async function getLatestBlockNumber(): Promise<number> {
  const response = await fetch(EVM_RPC_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "eth_blockNumber",
      params: [],
      id: 1,
    }),
  });
  const data: LatestBlockNumberResponse = await response.json();
  return parseInt(data.result, 16);
}

// Function to get EVM block by timestamp (binary search)
export async function getEVMBlockByTimestamp(
  timestamp: number
): Promise<number> {
  const latestBlock = await getLatestBlockNumber();
  let startBlock = 0;
  let endBlock = latestBlock;
  let closestBlock = 0;
  let closestTimeDifference = Number.MAX_SAFE_INTEGER;

  while (startBlock <= endBlock) {
    const middleBlock = Math.floor((startBlock + endBlock) / 2);
    const middleBlockTime = await getBlockTimestamp(middleBlock);
    const timeDifference = Math.abs(middleBlockTime - timestamp);

    if (timeDifference < closestTimeDifference) {
      closestBlock = middleBlock;
      closestTimeDifference = timeDifference;
    }

    if (middleBlockTime === timestamp) {
      return middleBlock;
    } else if (middleBlockTime < timestamp) {
      startBlock = middleBlock + 1;
    } else {
      endBlock = middleBlock - 1;
    }
  }

  return closestBlock;
}

// Solana Functions

// Function to get the latest slot number (Solana)
export async function getLatestSlot(): Promise<number> {
  const response = await fetch(SOLANA_RPC_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "getSlot",
      params: [],
      id: 1,
    }),
  });
  const data = (await response.json()) as { result: number };
  return data.result;
}

// Function to get slot time from Solana with caching
export async function getCachedSlotTime(slot: number): Promise<number> {
  return getCachedData(slotTimeCache, slot, async () => {
    return await getSlotTime(slot);
  });
}

// Function to get slot time from Solana
export async function getSlotTime(slot: number): Promise<number> {
  const response = await fetch(SOLANA_RPC_URL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "getBlockTime",
      params: [slot],
      id: 1,
    }),
  });
  const data = (await response.json()) as { result: number | null };
  if (data.result === null)
    throw new Error(`No timestamp found for slot ${slot}`);
  return data.result;
}

// Function to get block number for Solana by timestamp
export async function getSolanaBlockByTimestamp(
  timestamp: number
): Promise<number> {
  const latestSlot = await getLatestSlot();
  const genesisTimestamp = await getCachedSlotTime(0);

  if (timestamp <= genesisTimestamp) return 0;

  let startSlot = 0;
  let endSlot = latestSlot;
  let closestSlot = 0;
  let closestTimeDifference = Number.MAX_SAFE_INTEGER;

  while (startSlot <= endSlot) {
    const middleSlot = Math.floor((startSlot + endSlot) / 2);
    const middleSlotTime = await getCachedSlotTime(middleSlot);
    const timeDifference = Math.abs(middleSlotTime - timestamp);

    if (timeDifference < closestTimeDifference) {
      closestSlot = middleSlot;
      closestTimeDifference = timeDifference;
    }

    if (middleSlotTime === timestamp) {
      return middleSlot;
    } else if (middleSlotTime < timestamp) {
      startSlot = middleSlot + 1;
    } else {
      endSlot = middleSlot - 1;
    }
  }

  return await refineSlotSearchSolana(closestSlot, timestamp);
}

// Function to refine slot search for Solana
async function refineSlotSearchSolana(
  initialSlot: number,
  targetTimestamp: number
): Promise<number> {
  let closestSlot = initialSlot;
  let closestTimeDifference = Math.abs(
    (await getCachedSlotTime(initialSlot)) - targetTimestamp
  );

  for (let offset = 1; offset <= MAX_SEARCH_OFFSET; offset++) {
    const forwardSlot = initialSlot + offset;
    const backwardSlot = initialSlot - offset;

    const forwardTime = await getCachedSlotTime(forwardSlot);
    const forwardDifference = Math.abs(forwardTime - targetTimestamp);
    if (forwardDifference < closestTimeDifference) {
      closestSlot = forwardSlot;
      closestTimeDifference = forwardDifference;
    }

    const backwardTime = await getCachedSlotTime(backwardSlot);
    const backwardDifference = Math.abs(backwardTime - targetTimestamp);
    if (backwardDifference < closestTimeDifference) {
      closestSlot = backwardSlot;
      closestTimeDifference = backwardDifference;
    }

    if (closestTimeDifference <= TIME_DIFFERENCE_THRESHOLD) break;
  }

  return closestSlot;
}

// Function to get timestamp by block number (EVM)
export async function getTimestampByBlockNumber(
  blockNumber: number
): Promise<number> {
  return getBlockTimestamp(blockNumber);
}

// Function to get timestamp by slot number (Solana)
export async function getTimestampBySlot(slot: number): Promise<number> {
  const latestSlot = await getLatestSlot();
  if (slot < 0 || slot > latestSlot) {
    throw new Error(
      `Slot ${slot} is out of range. Latest slot is ${latestSlot}.`
    );
  }
  return getCachedSlotTime(slot);
}

================
File: src/index.ts
================
import { Hono } from 'hono';
import { handleApiRoute } from './routes/api';

const app = new Hono();

// Definicja prostego endpointu testowego
app.get('/', (c) => c.text('Hello from Cloudflare Workers!'));

// Definicja endpointu `/api`
app.get('/api', handleApiRoute);

export default app;

================
File: test/block.fetcher.test.ts
================
import { describe, it, expect, vi } from 'vitest';
import { delay, retry, getBlockTimestamp, getTimestampByBlockNumber, getTimestampBySlot, getLatestSlot, getCachedSlotTime } from '../src/utils/block-fetcher';

describe('block-fetcher', () => {
  it('should delay execution for the specified time', async () => {
    const start = Date.now();
    await delay(100);
    const end = Date.now();
    expect(end - start).toBeGreaterThanOrEqual(100);
  });

  it('should retry the function on failure and succeed', async () => {
    const mockFn = vi.fn()
      .mockRejectedValueOnce(new Error('First attempt failed'))
      .mockResolvedValueOnce('Success');
    
    const result = await retry(mockFn, 2, 100);
    expect(result).toBe('Success');
    expect(mockFn).toHaveBeenCalledTimes(2);
  });

  it('should throw an error after max retries', async () => {
    const mockFn = vi.fn().mockRejectedValue(new Error('Always fails'));
    
    await expect(retry(mockFn, 2, 100)).rejects.toThrow('Max retries reached: Error: Always fails');
    expect(mockFn).toHaveBeenCalledTimes(2);
  });

  it('should fetch block timestamp', async () => {
    // Mock fetch response
    global.fetch = vi.fn().mockResolvedValue({
      json: async () => ({
        result: {
          timestamp: '0x5f5e100'
        }
      })
    });

    const timestamp = await getBlockTimestamp(123456);
    expect(timestamp).toBe(100000000);
  });

  it('should get timestamp by block number', async () => {
    // Spy on getBlockTimestamp function
    const mockGetBlockTimestamp = vi.spyOn({ getBlockTimestamp }, 'getBlockTimestamp').mockResolvedValue(100000000);

    const timestamp = await getTimestampByBlockNumber(123456);
    expect(timestamp).toBe(100000000);
    expect(mockGetBlockTimestamp).toHaveBeenCalledWith(123456);

    // Restore original function
    mockGetBlockTimestamp.mockRestore();
  });

  it('should get timestamp by slot number', async () => {
    // Spy on getLatestSlot and getCachedSlotTime functions
    const mockGetLatestSlot = vi.spyOn({ getLatestSlot }, 'getLatestSlot').mockResolvedValue(200000);
    const mockGetCachedSlotTime = vi.spyOn({ getCachedSlotTime }, 'getCachedSlotTime').mockResolvedValue(100000000);

    const timestamp = await getTimestampBySlot(123456);
    expect(timestamp).toBe(100000000);
    expect(mockGetLatestSlot).toHaveBeenCalled();
    expect(mockGetCachedSlotTime).toHaveBeenCalledWith(123456);

    // Restore original functions
    mockGetLatestSlot.mockRestore();
    mockGetCachedSlotTime.mockRestore();
  });

  it('should throw an error if slot number is out of range', async () => {
    // Spy on getLatestSlot function
    const mockGetLatestSlot = vi.spyOn({ getLatestSlot }, 'getLatestSlot').mockResolvedValue(100000);

    await expect(getTimestampBySlot(200000)).rejects.toThrow('Slot 200000 is out of range. Latest slot is 100000.');

    // Restore original function
    mockGetLatestSlot.mockRestore();
  });
});

================
File: test/tsconfig.json
================
{
    "extends": "../tsconfig.json",
    "compilerOptions": {
      "moduleResolution": "bundler",
      "types": [
        "@cloudflare/workers-types/experimental",
        "@cloudflare/vitest-pool-workers"
      ]
    },
    "include": ["./**/*.ts", "../src/env.d.ts"]
  }

================
File: .gitignore
================
# prod
dist/

# dev
.yarn/
!.yarn/releases
.vscode/*
!.vscode/launch.json
!.vscode/*.code-snippets
.idea/workspace.xml
.idea/usage.statistics.xml
.idea/shelf

# deps
node_modules/
.wrangler

# env
.env
.env.production
.dev.vars

# logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

# misc
.DS_Store

================
File: package.json
================
{
  "name": "Block_searcher_CW",
  "scripts": {
    "dev": "wrangler dev",
    "deploy": "wrangler deploy --minify",
    "test": "vitest"
  },
  "dependencies": {
    "hono": "^4.6.9"
  },
  "devDependencies": {
    "@cloudflare/vitest-pool-workers": "^0.5.40",
    "@cloudflare/workers-types": "^4.20241022.0",
    "vitest": "2.1.8",
    "wrangler": "^3.83.0"
  }
}

================
File: README.md
================
```
npm install
npm run dev
```

```
npm run deploy
```

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "skipLibCheck": true,
    "lib": [
      "ESNext"
    ],
    "types": [
      "@cloudflare/workers-types/2023-07-01"
    ],
    "jsx": "react-jsx",
    "jsxImportSource": "hono/jsx"
  },
}

================
File: vitest.config.ts
================
import { defineWorkersConfig } from "@cloudflare/vitest-pool-workers/config";

export default defineWorkersConfig({
  test: {
    poolOptions: {
      workers: {
        wrangler: { configPath: "./wrangler.toml" },
      },
    },
  },
});

================
File: wrangler.toml
================
name = "block_searcher_cw"
main = "src/index.ts"
compatibility_date = "2024-11-07"

compatibility_flags = ["nodejs_compat"]

# [vars]
# MY_VAR = "my-variable"

# [[kv_namespaces]]
# binding = "MY_KV_NAMESPACE"
account_id = "08cb3f6365e5921372431dfad92bd8ae"

# [[r2_buckets]]
# binding = "MY_BUCKET"
# bucket_name = "my-bucket"

# [[d1_databases]]
# binding = "DB"
# database_name = "my-database"
# database_id = ""

# [ai]
# binding = "AI"

# [observability]
# enabled = true
# head_sampling_rate = 1
